https://www.cnblogs.com/geek6/p/3951677.html
# 面向对象的设计模式

设计模式的原则：

- 回顾 solid(单一，开闭，里氏置换，接口分离，依赖倒置)

总原则：开闭原则，对扩展开放，对修改关闭。

在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等

## 创建型模式
- [工厂模式](#factory)
- [单例模式](#singleton)
- [建造者模式](#builder)
- [原型链模式](#prototype-chain)

### <a name="factory"></a>工厂模式

1. 简单工厂模式

    简单工厂模式氛围三种:
   -  普通

        就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建
        示例：`factory/simple.ts`
   -  多个方法

        是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象
        示例：`factory/simple.ts`
   -  多个静态方法

        将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可
        示例：`factory/simple.ts`

2. 工厂方法模式

    简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。
    示例：`factory/factory-method.ts`


3. 抽象工厂模式

    工厂方法模式引入工厂等级结构，解决了简单工厂模式中工厂类职责过重的问题，但由于工厂方法模式中每个工厂只创建一类具体类的对象，这将会导致系统当中的工厂类过多，这势必会增加系统的开销。此时，我们可以考虑将一些相关的具体类组成一个“具体类族”，由同一个工厂来统一生产，这就是我们本文要说的“抽象工厂模式”的基本思想。

    抽象工厂模式是工厂方法模式的进一步延伸， 由于它提供了功能更为强大的工厂类并且具备较好的可扩展性

### <a name="singleton"></a>单例模式

### <a name="builder"></a>建造者模式

### <a name="prototype-chain"></a>原型模式




## 结构型模式

### 适配器模式
### 代理模式
### 装饰器模式
### 外观模式
### 桥接模式
### 组合模式
### 享元模式




## 行为型模式

### 策略模式

### 观察者模式

### 模板方法模式

### 责任链模式

### 命令模式

### 迭代子模式

### 状态模式

### 备忘录模式

### 访问者模式

### 中介者模式

### 解释器模式